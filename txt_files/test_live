
c = h(a)
    a,b = cx(c,b)

    return b

@guppy(module)
def fun(z: qubit):
    r = qubit()
    for e:
        a = qubit()
        a = fun(a)
        z,a,r = toff(z,a,r)
        #discard(a)

    u = measure(u)
    #u = qubit()
    if u:
        c = h(r)
    else:
        #consumed u used
        c = h(u)

    # unused z
    z,c = cx(z,c)
    return c

@guppy(module)
def loop_consume(_: qubit) -> qubit:
    x,y,r = qubit()

    a = qubit()
    while e:
        x,a = cx(x,a)
        y,a = cx(y,a)
        a,y,r = toff(a,y,r)

    if e:
        _ = measure(a)
    else:
        _ = measure(y)

    return x,r



@guppy(module)
# qua io devo inserire i 2 discard
def cond_overwriting(_: qubit) -> qubit:
    c = qubit()
    if e:
        b = qubit()
        if e:
            b = x(b)
            #discard(b)
        else:
            #discard(b)
            pass

    b = qubit()


    return b,c


@guppy(module)
def loop_consume(_: qubit) -> qubit:
    c = qubit()
    while e:
        b = qubit()
        b = x(b)
        discard(b)

    return c





@guppy
def and3(x: qubit,y: qubit,z: qubit):
    r,a = qubit(),qubit()
    x,y,a = toff(x,y,a)
    z,a,r = toff(z,a,r)

    return x,y,z,r



@guppy
# we need to uncompute c in the else branch of the first if
# and b in the else branch of the first if and in the else of the second
def unc_example(b: qubit):
    c = qubit()
    if e:
        m = measure(b)
        if m:
            a = h(c)
        else:
            a = qubit()
    else:
        a = qubit()

    return a





@guppy(module)
def cond_consume(_: qubit) -> qubit:
    c = qubit()
    if e:
        #b = qubit()
        b = x(c)
    else:
        b = qubit()


    return b


@guppy(module)
def cond_consume(_) -> qubit:
    b = qubit()
    b = x(b)
    t = qubit()
    t = h(t)
    e = measure(t)
    if e:
        c = x(b)
    else:
        # da aggiungere!!
        # discard(b)
        c = qubit()

    return c


@guppy(module)
def toffoli(c1: qubit, c2: qubit, tgt: qubit) -> tuple[qubit, qubit, qubit]:
    tgt = h(tgt)
    tgt = h(tgt)
    c2, tgt = cx(c2, tgt)
    tgt = tdg(tgt)
    c1, tgt = cx(c1, tgt)
    tgt = t(tgt)
    c2, tgt = cx(c2, tgt)
    tgt = tdg(tgt)
    c1, tgt = cx(c1, tgt)
    c2 = t(c2)
    tgt = t(tgt)
    c1, c2 = cx(c1, c2)
    tgt = h(tgt)
    c1 = t(c1)
    c2 = tdg(c2)
    c1, c2 = cx(c1, c2)

    return c1, c2, tgt


@guppy(module)
def overwrite(q: qubit, tries: int) -> qubit:
    b = h(qubit())
    for _ in [0, tries]:
        # da aggiungere se no non tipa:
        discard(b)

        a, b = h(qubit()), h(qubit())
        measure(a)
        # b, a = cx(b, tdg(a))
        # if not measure(t(a)):
        # First part failed ; try again
        # discard (b)
        # continue
        q, b = cx(z(t(q)), b)

    measure(b)
    return q


@guppy(module)
def overwrite2(q: qubit, tries: int) -> qubit:
    b = qubit()
    for _ in [0, tries]:
        a = h(qubit())
        b, a = cx(b, tdg(a))
        if not measure(t(a)):
            # da aggiungere!!
            discard(b)
            b = qubit()
            continue
        q, b = cx(z(t(q)), b)

    measure(b)
    return q


@guppy(module)
def cond_consume(tries: int) -> qubit:
    b = x(qubit())
    if measure(h(qubit())):
        c = x(b)
    else:
        # da aggiungere!!
        discard(b)
        c = qubit()

    return c


@guppy(module)
def fun_call() -> tuple[qubit, qubit, qubit]:
    a, b, c = toffoli(qubit(), qubit(), qubit())

    return a, b, c


module.compile()
