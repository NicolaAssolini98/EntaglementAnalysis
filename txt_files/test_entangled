@guppy
# repetition of a control not
def test():
    a,b = qubit(),qubit()
    b = h(b)
    while _ :
        b,a = cx(b,a)

    return b,a

@guppy
def rus2(tries: int) -> Qubit:
    q = qubit()
    q = rx(q,_)
    while _ :
        a, b = qubit(), qubit()
        a = h(a)
        b = h(b)
        a = tdg(a)
        b, a = cx(b, a)
        a = t(a)
        e = measure(a)
        q, b = cx(q, b)
        if not e:
        # First part failed ; try again
            discard(b)
        else:
            b = t(b)
            e = measure(b)

    # Otherwise , apply correction
    q = x(q)

    return q


@guppy(module)
# rus from guppy PlanQc paper
def rus_planQc(tries: int) -> Qubit:
    q = qubit()
    q = rx(q,_)
    while _ :
        a, b = qubit(), qubit()
        a = h(a)
        b = h(b)
        a = tdg(a)
        b, a = cx(b, a)
        a = t(a)
        e = measure(a)
        if not e:
        # First part failed ; try again
            discard(b)
        else:
            q = t(q)
            q, b = cx(q, b)
            b = t(b)
            e = measure (b)

    # Otherwise , apply correction
    q = x(q)

    return q


@guppy(module)
def superdense_coding():
    c1,c2,q1,q2 = qubit(),qubit(),qubit(),qubit()

    q1 = h(q1)
    q1,q2 = cx(q1,q2)
    c1,q1 = cz(c1,q1)
    c2,q1 = cx(c2,q1)
    q1,q2 = cx(q1,q2)
    q1 = h(q1)

    return c1,c2,q1,q2


@guppy(module)
# we implement Uf = CNOT
def deutsch_with_balance_oracle():
    p,q = qubit(),qubit()
    q = x(q)
    p = h(p)
    q = h(q)
    p,q = cx(p,q)
    p = h(p)

    a = measure(p)

    return q


# this program produces the state |00> + |1->, measure the second variable
# correspond to the cricuit h(q1);ch(q1,q2);measure(q2)
@guppy(module)
def ctrl_hadamard():
    c, t = qubit()
    c = h(c)
    # controlled hadamard:
    t = s(t)
    t = h(t)
    t = t(t)
    c,t = cx(c,t)
    t = tdg(t)
    t = h(t)
    t = sdg(t)

    a = measure(t)
    return c,t

@guppy(module)
def teleport() -> qubit :
    # Entangle qubits with ancilla
    tmp,src,tgt = qubit(),qubit(),qubit()
    src = rx(_,src)
    tmp = h(tmp)
    tmp, tgt = cx(tmp, tgt)
    src, tmp = cx(src , tmp)
    src = h(src)
    m = measure(src)
    if m:
        tgt = z(tgt)
    m = measure(tmp)
    if m:
        tgt = x(tgt)

    # Apply classical corrections

    return tgt

@guppy(module)
def GHZ() -> _:
    x,y,z = qubit(), qubit(), qubit()
    x = h(x)
    x,y = cx(x,y)
    y,z = cx(y,z)

    return x,y,z

@guppy(module)
def GHZ_QAI() -> _:
    x,y,z = qubit(), qubit(), qubit()
    x = h(x)
    y = h(y)
    x,z = cx(x,z)
    y,z = cx(y,z)
    x = h(x)
    y = h(y)
    z = h(z)

    return x,y,z

@guppy(module)
def GHZ_dis1() -> _:
    x,y,z = qubit(), qubit(), qubit()
    x = h(x)
    x,y = cx(x,y)
    y,z = cx(y,z)
    x,y = cx(x,y)
    y,z = cx(y,z)

    return x,y,z

@guppy(module)
def GHZ_dis2() -> _:
    x,y,z = qubit(), qubit(), qubit()
    x = h(x)
    x,y = cx(x,y)
    x,z = cx(x,z)
    x,y = cx(x,y)
    x,z = cx(x,z)

    return x,y,z

@guppy(module)
def main():
    x = qubit()
    x = h(x)
    x = s(x)
    x = rx(x,_)
    x = t(x)

    return x


