import sys

sys.path.append("..")
from guppylang.prelude.quantum import *

# import guppylang.prelude.quantum as quantum

module = GuppyModule("test")
module.load(quantum)



# Teleports the state in `src` to `tgt`.
@guppy(module)
def toffoli(c1: qubit, c2: qubit, tgt: qubit) -> tuple[qubit, qubit, qubit]:
    tgt = h(tgt)
    tgt = h(tgt)
    c2, tgt = cx(c2, tgt)
    tgt = tdg(tgt)
    c1, tgt = cx(c1, tgt)
    tgt = t(tgt)
    c2, tgt = cx(c2, tgt)
    tgt = tdg(tgt)
    c1, tgt = cx(c1, tgt)
    c2 = t(c2)
    tgt = t(tgt)
    c1, c2 = cx(c1, c2)
    tgt = h(tgt)
    c1 = t(c1)
    c2 = tdg(c2)
    c1, c2 = cx(c1, c2)

    return c1, c2, tgt


@guppy(module)
def overwrite(q: qubit, tries: int) -> qubit:
    b = h(qubit())
    for _ in [0, tries]:
        # da aggiungere se no non tipa:
        discard(b)

        a, b = h(qubit()), h(qubit())
        measure(a)
        # b, a = cx(b, tdg(a))
        # if not measure(t(a)):
        # First part failed ; try again
        # discard (b)
        # continue
        q, b = cx(z(t(q)), b)

    measure(b)
    return q


@guppy(module)
def overwrite2(q: qubit, tries: int) -> qubit:
    b = qubit()
    for _ in [0, tries]:
        a = h(qubit())
        b, a = cx(b, tdg(a))
        if not measure(t(a)):
            # da aggiungere!!
            discard(b)
            b = qubit()
            continue
        q, b = cx(z(t(q)), b)

    measure(b)
    return q


@guppy(module)
def cond_consume(tries: int) -> qubit:
    b = x(qubit())
    if measure(h(qubit())):
        c = x(b)
    else:
        # da aggiungere!!
        discard(b)
        c = qubit()

    return c


@guppy(module)
def fun_call() -> tuple[qubit, qubit, qubit]:
    a, b, c = toffoli(qubit(), qubit(), qubit())

    return a, b, c


module.compile()
